----------------------------------------------------------------------------------
-- Overflow and Underflow Detection Unit
-- Designed for 16-bit Floating-Point Multiplier
-- Integrates with existing FSM (States S0-S6)
-- 
-- Format: Sign(1) | Exponent(7) | Mantissa(8) = 16 bits
-- Exponent: Excess-63 representation
-- Valid exponent range: 1 to 126 (stored values)
-- Actual exponent range: -62 to 63 (E = E' - 63)
----------------------------------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.std_logic_unsigned.ALL;

ENTITY overflow_underflow_unit IS
    PORT(
        -- Clock and Reset
        i_clock           : IN  STD_LOGIC;
        i_resetBar        : IN  STD_LOGIC;  -- Active low reset (matching your FSM)
        
        -- Inputs from Datapath
        i_exponent_sum    : IN  STD_LOGIC_VECTOR(7 DOWNTO 0);  -- 8-bit exponent after addition
        i_normalization   : IN  STD_LOGIC;  -- From S2: normalization needed flag
        
        -- Control from FSM
        i_enable          : IN  STD_LOGIC;  -- Enable checking (from S3 or S4)
        
        -- Outputs
        o_overflow_under  : OUT STD_LOGIC;  -- Combined overflow/underflow flag (to FSM input)
        o_overflow        : OUT STD_LOGIC;  -- Separate overflow flag
        o_underflow       : OUT STD_LOGIC;  -- Separate underflow flag
        o_exponent_out    : OUT STD_LOGIC_VECTOR(6 DOWNTO 0)  -- Corrected exponent output
    );
END overflow_underflow_unit;

ARCHITECTURE structural OF overflow_underflow_unit IS
    
    -- Internal signals
    SIGNAL adjusted_exponent  : STD_LOGIC_VECTOR(7 DOWNTO 0);
    SIGNAL overflow_detected  : STD_LOGIC;
    SIGNAL underflow_detected : STD_LOGIC;
    SIGNAL combined_flag      : STD_LOGIC;
    SIGNAL final_exponent     : STD_LOGIC_VECTOR(6 DOWNTO 0);
    
    -- Exponent boundary constants (for 7-bit exponent, excess-63)
    CONSTANT MAX_EXPONENT : STD_LOGIC_VECTOR(7 DOWNTO 0) := "01111110";  -- 126 decimal
    CONSTANT MIN_EXPONENT : STD_LOGIC_VECTOR(7 DOWNTO 0) := "00000001";  -- 1 decimal
    CONSTANT ZERO_EXP     : STD_LOGIC_VECTOR(7 DOWNTO 0) := "00000000";  -- 0
    
BEGIN

    ----------------------------------------------------------------------------------
    -- EXPONENT ADJUSTMENT PROCESS
    -- Adjusts exponent based on normalization flag from mantissa multiplication
    -- If mantissa product >= 2.0 (MSB = 1), increment exponent by 1
    ----------------------------------------------------------------------------------
    exponent_adjust: PROCESS(i_exponent_sum, i_normalization)
    BEGIN
        IF i_normalization = '1' THEN
            -- Mantissa is >= 2.0, need to shift right, so increment exponent
            adjusted_exponent <= i_exponent_sum + "00000001";
        ELSE
            -- No normalization needed or mantissa < 2.0
            adjusted_exponent <= i_exponent_sum;
        END IF;
    END PROCESS;

    ----------------------------------------------------------------------------------
    -- OVERFLOW DETECTION
    -- Overflow occurs when the adjusted exponent exceeds the maximum value (126)
    -- This can happen when:
    --   1. The sum of exponents is too large
    --   2. Normalization pushes a boundary case over the limit
    ----------------------------------------------------------------------------------
    overflow_check: PROCESS(adjusted_exponent)
    BEGIN
        IF adjusted_exponent > MAX_EXPONENT THEN
            overflow_detected <= '1';
        ELSE
            overflow_detected <= '0';
        END IF;
    END PROCESS;

    ----------------------------------------------------------------------------------
    -- UNDERFLOW DETECTION  
    -- Underflow occurs when the adjusted exponent is below the minimum value (1)
    -- This happens when the sum of exponents results in a value less than 1
    -- In excess-63 format: E_result = E_A + E_B - 63
    -- If result < 1, we have underflow (denormalized number territory)
    ----------------------------------------------------------------------------------
    underflow_check: PROCESS(adjusted_exponent)
    BEGIN
        IF adjusted_exponent < MIN_EXPONENT THEN
            underflow_detected <= '1';
        ELSE
            underflow_detected <= '0';
        END IF;
    END PROCESS;

    ----------------------------------------------------------------------------------
    -- COMBINED FLAG GENERATION
    -- Your FSM uses i_overflow_under as a single input signal
    -- This combines both overflow and underflow into one exception flag
    ----------------------------------------------------------------------------------
    combined_flag <= overflow_detected OR underflow_detected;

    ----------------------------------------------------------------------------------
    -- EXPONENT OUTPUT CORRECTION
    -- Handles exponent saturation and clamping:
    --   - Overflow: Saturate to maximum value (126)
    --   - Underflow: Clamp to zero (denormalized/flush to zero)
    --   - Normal: Pass through the adjusted exponent (lower 7 bits)
    ----------------------------------------------------------------------------------
    exponent_correction: PROCESS(adjusted_exponent, overflow_detected, underflow_detected)
    BEGIN
        IF overflow_detected = '1' THEN
            -- Saturate to maximum exponent
            final_exponent <= MAX_EXPONENT(6 DOWNTO 0);  -- "1111110"
        ELSIF underflow_detected = '1' THEN
            -- Flush to zero (denormalized number)
            final_exponent <= (OTHERS => '0');  -- "0000000"
        ELSE
            -- Normal case: take lower 7 bits of adjusted exponent
            final_exponent <= adjusted_exponent(6 DOWNTO 0);
        END IF;
    END PROCESS;

    ----------------------------------------------------------------------------------
    -- OUTPUT REGISTER
    -- Synchronous output with active-low reset (matching your FSM style)
    -- Outputs are only updated when enabled by the FSM
    ----------------------------------------------------------------------------------
    output_register: PROCESS(i_clock, i_resetBar)
    BEGIN
        IF i_resetBar = '0' THEN
            -- Active low reset
            o_overflow_under <= '0';
            o_overflow       <= '0';
            o_underflow      <= '0';
            o_exponent_out   <= (OTHERS => '0');
        ELSIF rising_edge(i_clock) THEN
            IF i_enable = '1' THEN
                -- Update outputs when enabled
                o_overflow_under <= combined_flag;
                o_overflow       <= overflow_detected;
                o_underflow      <= underflow_detected;
                o_exponent_out   <= final_exponent;
            END IF;
        END IF;
    END PROCESS;

END structural;