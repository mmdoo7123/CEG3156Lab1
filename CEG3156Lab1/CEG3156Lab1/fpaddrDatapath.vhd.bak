--------------------------------------------------------------------------------
-- 16-Bit Floating-Point Adder - DATAPATH
-- Format: [15] Sign, [14:8] Exponent (7-bit, bias=63), [7:0] Mantissa (8-bit)
-- Implements exponent alignment and fraction addition
--------------------------------------------------------------------------------

LIBRARY ieee;
USE ieee.std_logic_1164.ALL;
USE ieee.numeric_std.ALL;

ENTITY fpaddrDatapath IS
    PORT(
        -- Clock and Reset
        i_clock     : IN  STD_LOGIC;
        i_reset     : IN  STD_LOGIC;
        
        -- Inputs
        SignA       : IN  STD_LOGIC;
        MantissaA   : IN  STD_LOGIC_VECTOR(7 DOWNTO 0);
        ExponentA   : IN  STD_LOGIC_VECTOR(6 DOWNTO 0);
        SignB       : IN  STD_LOGIC;
        MantissaB   : IN  STD_LOGIC_VECTOR(7 DOWNTO 0);
        ExponentB   : IN  STD_LOGIC_VECTOR(6 DOWNTO 0);
        
        -- Control Signals from Control Path
        loadInputs    : IN  STD_LOGIC;  -- Load A and B into registers
        calcExpDiff   : IN  STD_LOGIC;  -- Calculate exponent difference
        negateEdiff   : IN  STD_LOGIC;  -- Take absolute value of Ediff
        setFLAG       : IN  STD_LOGIC;  -- Set FLAG (Y is larger)
        shiftSmaller  : IN  STD_LOGIC;  -- Shift the smaller mantissa
        clearSmaller  : IN  STD_LOGIC;  -- Clear smaller mantissa if diff too large
        addFractions  : IN  STD_LOGIC;  -- Add aligned fractions
        selectExp     : IN  STD_LOGIC;  -- Select correct exponent (0=X, 1=Y)
        normalize     : IN  STD_LOGIC;  -- Normalize if overflow
        
        -- Status Signals to Control Path
        ediffNegative : OUT STD_LOGIC;  -- Ediff < 0
        ediffLarge    : OUT STD_LOGIC;  -- Ediff >= 9 (larger than mantissa width)
        needsNorm     : OUT STD_LOGIC;  -- Result needs normalization
        
        -- Outputs
        SignOut       : OUT STD_LOGIC;
        MantissaOut   : OUT STD_LOGIC_VECTOR(7 DOWNTO 0);
        ExponentOut   : OUT STD_LOGIC_VECTOR(6 DOWNTO 0);
        Overflow      : OUT STD_LOGIC
    );
END fpaddrDatapath;

ARCHITECTURE structural OF fpaddrDatapath IS
    
    -- Component Declarations
    COMPONENT genericAdder IS
        GENERIC (n : integer := 8);
        PORT(
            i_Ai, i_Bi  : IN  STD_LOGIC_VECTOR(n-1 DOWNTO 0);
            i_CarryIn   : IN  STD_LOGIC;
            o_Sum       : OUT STD_LOGIC_VECTOR(n-1 DOWNTO 0);
            o_CarryOut  : OUT STD_LOGIC
        );
    END COMPONENT;
    
    COMPONENT genericMux2to1 IS
        GENERIC (n : integer := 8);
        PORT(
            i_A, i_B  : IN  STD_LOGIC_VECTOR(n-1 DOWNTO 0);
            i_Sel     : IN  STD_LOGIC;
            o_Out     : OUT STD_LOGIC_VECTOR(n-1 DOWNTO 0)
        );
    END COMPONENT;
    
    COMPONENT genericRegister IS
        GENERIC (n : integer := 8);
        PORT(
            i_clock     : IN  STD_LOGIC;
            i_resetBar  : IN  STD_LOGIC;
            i_load      : IN  STD_LOGIC;
            i_data      : IN  STD_LOGIC_VECTOR(n-1 DOWNTO 0);
            o_q         : OUT STD_LOGIC_VECTOR(n-1 DOWNTO 0)
        );
    END COMPONENT;
    
    -- Internal Signals
    signal resetBar : STD_LOGIC;
    
    -- Registers for mantissas with implicit 1 (9 bits = 1.MMMMMMMM)
    signal regMantA      : STD_LOGIC_VECTOR(8 DOWNTO 0);  -- 1.MantissaA
    signal regMantB      : STD_LOGIC_VECTOR(8 DOWNTO 0);  -- 1.MantissaB
    signal regMantA_data : STD_LOGIC_VECTOR(8 DOWNTO 0);
    signal regMantB_data : STD_LOGIC_VECTOR(8 DOWNTO 0);
    
    -- Registers for exponents
    signal regExpA       : STD_LOGIC_VECTOR(6 DOWNTO 0);
    signal regExpB       : STD_LOGIC_VECTOR(6 DOWNTO 0);
    
    -- Sign registers
    signal regSignA      : STD_LOGIC;
    signal regSignB      : STD_LOGIC;
    
    -- Exponent difference
    signal ediff         : STD_LOGIC_VECTOR(7 DOWNTO 0);  -- 8 bits to handle sign
    signal ediff_abs     : STD_LOGIC_VECTOR(7 DOWNTO 0);  -- Absolute value
    signal ediff_data    : STD_LOGIC_VECTOR(7 DOWNTO 0);
    signal expA_extended : STD_LOGIC_VECTOR(7 DOWNTO 0);
    signal expB_extended : STD_LOGIC_VECTOR(7 DOWNTO 0);
    signal expB_negated  : STD_LOGIC_VECTOR(7 DOWNTO 0);
    signal ediff_negated : STD_LOGIC_VECTOR(7 DOWNTO 0);
    signal exp_carry_out : STD_LOGIC;
    
    -- FLAG register (indicates which operand is larger)
    signal FLAG          : STD_LOGIC;
    signal FLAG_data     : STD_LOGIC;
    
    -- Shifter outputs
    signal mantA_shifted : STD_LOGIC_VECTOR(8 DOWNTO 0);
    signal mantB_shifted : STD_LOGIC_VECTOR(8 DOWNTO 0);
    
    -- Aligned mantissas after shift/clear
    signal mantA_aligned : STD_LOGIC_VECTOR(8 DOWNTO 0);
    signal mantB_aligned : STD_LOGIC_VECTOR(8 DOWNTO 0);
    
    -- Addition result (10 bits to handle overflow)
    signal frac_sum      : STD_LOGIC_VECTOR(9 DOWNTO 0);
    signal frac_sum_extended : STD_LOGIC_VECTOR(9 DOWNTO 0);
    signal frac_carry    : STD_LOGIC;
    
    -- Result registers
    signal regFracResult : STD_LOGIC_VECTOR(9 DOWNTO 0);
    signal regExpResult  : STD_LOGIC_VECTOR(6 DOWNTO 0);
    signal regSignResult : STD_LOGIC;
    
    -- Normalized values
    signal frac_normalized : STD_LOGIC_VECTOR(9 DOWNTO 0);
    signal exp_normalized  : STD_LOGIC_VECTOR(6 DOWNTO 0);
    signal exp_incremented : STD_LOGIC_VECTOR(6 DOWNTO 0);
    signal exp_inc_carry   : STD_LOGIC;
    
    -- Selected exponent
    signal exp_selected  : STD_LOGIC_VECTOR(6 DOWNTO 0);
    
    -- Shift amount (limited to 0-8)
    signal shift_amount  : INTEGER RANGE 0 TO 8;
    
BEGIN
    
    resetBar <= NOT i_reset;
    
    -- ========================================================================
    -- INPUT STAGE: Load inputs and prepend implicit 1 to mantissas
    -- ========================================================================
    
    regMantA_data <= '1' & MantissaA;  -- Create 1.MMMMMMMM format
    regMantB_data <= '1' & MantissaB;
    
    -- Mantissa A Register (9 bits)
    REG_MANT_A: genericRegister
        GENERIC MAP (n => 9)
        PORT MAP (
            i_clock    => i_clock,
            i_resetBar => resetBar,
            i_load     => loadInputs,
            i_data     => regMantA_data,
            o_q        => regMantA
        );
    
    -- Mantissa B Register (9 bits)
    REG_MANT_B: genericRegister
        GENERIC MAP (n => 9)
        PORT MAP (
            i_clock    => i_clock,
            i_resetBar => resetBar,
            i_load     => loadInputs,
            i_data     => regMantB_data,
            o_q        => regMantB
        );
    
    -- Exponent A Register (7 bits)
    REG_EXP_A: genericRegister
        GENERIC MAP (n => 7)
        PORT MAP (
            i_clock    => i_clock,
            i_resetBar => resetBar,
            i_load     => loadInputs,
            i_data     => ExponentA,
            o_q        => regExpA
        );
    
    -- Exponent B Register (7 bits)
    REG_EXP_B: genericRegister
        GENERIC MAP (n => 7)
        PORT MAP (
            i_clock    => i_clock,
            i_resetBar => resetBar,
            i_load     => loadInputs,
            i_data     => ExponentB,
            o_q        => regExpB
        );
    
    -- Sign registers (using 1-bit portion of generic register)
    process(i_clock, i_reset)
    begin
        if i_reset = '1' then
            regSignA <= '0';
            regSignB <= '0';
        elsif rising_edge(i_clock) then
            if loadInputs = '1' then
                regSignA <= SignA;
                regSignB <= SignB;
            end if;
        end if;
    end process;
    
    -- ========================================================================
    -- EXPONENT DIFFERENCE CALCULATION: Ediff = ExpA - ExpB
    -- ========================================================================
    
    -- Extend exponents to 8 bits for signed arithmetic
    expA_extended <= '0' & regExpA;
    expB_extended <= '0' & regExpB;
    
    -- Negate ExpB for subtraction (2's complement)
    NEG_EXPB: FOR i IN 0 TO 7 GENERATE
        expB_negated(i) <= NOT expB_extended(i);
    END GENERATE;
    
    -- ExpA - ExpB = ExpA + (-ExpB) = ExpA + (NOT ExpB) + 1
    ADDER_EXPDIFF: genericAdder
        GENERIC MAP (n => 8)
        PORT MAP (
            i_Ai       => expA_extended,
            i_Bi       => expB_negated,
            i_CarryIn  => '1',  -- Add 1 for 2's complement
            o_Sum      => ediff_data,
            o_CarryOut => exp_carry_out
        );
    
    -- Ediff Register
    REG_EDIFF: genericRegister
        GENERIC MAP (n => 8)
        PORT MAP (
            i_clock    => i_clock,
            i_resetBar => resetBar,
            i_load     => calcExpDiff,
            i_data     => ediff_data,
            o_q        => ediff
        );
    
    -- Status: Check if Ediff is negative (MSB = 1)
    ediffNegative <= ediff(7);
    
    -- ========================================================================
    -- ABSOLUTE VALUE OF EDIFF (if negative)
    -- ========================================================================
    
    -- Negate Ediff for absolute value
    NEG_EDIFF: FOR i IN 0 TO 7 GENERATE
        ediff_negated(i) <= NOT ediff(i);
    END GENERATE;
    
    ADDER_ABS: genericAdder
        GENERIC MAP (n => 8)
        PORT MAP (
            i_Ai       => ediff_negated,
            i_Bi       => (others => '0'),
            i_CarryIn  => '1',  -- Add 1 for 2's complement
            o_Sum      => ediff_abs,
            o_CarryOut => open
        );
    
    -- Use absolute value for shifting
    -- If negateEdiff is asserted, update ediff register with absolute value
    process(i_clock, i_reset)
    begin
        if i_reset = '1' then
            shift_amount <= 0;
        elsif rising_edge(i_clock) then
            if negateEdiff = '1' then
                -- Use absolute value
                if unsigned(ediff_abs(7 DOWNTO 0)) >= 9 then
                    shift_amount <= 8;  -- Max shift
                else
                    shift_amount <= to_integer(unsigned(ediff_abs(2 DOWNTO 0)));
                end if;
            elsif calcExpDiff = '1' then
                -- Use direct value (positive)
                if unsigned(ediff(7 DOWNTO 0)) >= 9 then
                    shift_amount <= 8;
                else
                    shift_amount <= to_integer(unsigned(ediff(2 DOWNTO 0)));
                end if;
            end if;
        end if;
    end process;
    
    -- Check if difference is too large (>= 9)
    ediffLarge <= '1' when (negateEdiff = '1' and unsigned(ediff_abs) >= 9) or
                           (negateEdiff = '0' and unsigned(ediff) >= 9) else '0';
    
    -- ========================================================================
    -- FLAG REGISTER: Indicates which operand has larger exponent
    -- ========================================================================
    
    FLAG_data <= '1' when setFLAG = '1' else '0';
    
    process(i_clock, i_reset)
    begin
        if i_reset = '1' then
            FLAG <= '0';
        elsif rising_edge(i_clock) then
            if calcExpDiff = '1' then
                FLAG <= '0';  -- Clear FLAG initially
            elsif setFLAG = '1' then
                FLAG <= '1';  -- Set if ExpB > ExpA
            end if;
        end if;
    end process;
    
    -- ========================================================================
    -- ALIGNMENT: Shift smaller mantissa right by |Ediff| positions
    -- ========================================================================
    
    -- Barrel shifter for Mantissa A (shift right)
    process(regMantA, shift_amount, shiftSmaller, negateEdiff)
    begin
        if shiftSmaller = '1' and negateEdiff = '1' then
            -- Shift mantissa A right
            mantA_shifted <= std_logic_vector(shift_right(unsigned(regMantA), shift_amount));
        else
            mantA_shifted <= regMantA;
        end if;
    end process;
    
    -- Barrel shifter for Mantissa B (shift right)
    process(regMantB, shift_amount, shiftSmaller, negateEdiff)
    begin
        if shiftSmaller = '1' and negateEdiff = '0' then
            -- Shift mantissa B right
            mantB_shifted <= std_logic_vector(shift_right(unsigned(regMantB), shift_amount));
        else
            mantB_shifted <= regMantB;
        end if;
    end process;
    
    -- Clear smaller mantissa if difference too large
    process(mantA_shifted, mantB_shifted, clearSmaller, ediffLarge, negateEdiff)
    begin
        if clearSmaller = '1' and ediffLarge = '1' then
            if negateEdiff = '1' then
                mantA_aligned <= (others => '0');
                mantB_aligned <= mantB_shifted;
            else
                mantA_aligned <= mantA_shifted;
                mantB_aligned <= (others => '0');
            end if;
        else
            mantA_aligned <= mantA_shifted;
            mantB_aligned <= mantB_shifted;
        end if;
    end process;
    
    -- ========================================================================
    -- FRACTION ADDITION
    -- ========================================================================
    
    -- Extend to 10 bits for addition with overflow bit
    frac_sum_extended <= ('0' & mantA_aligned) when addFractions = '0' else
                         ('0' & mantA_aligned);
    
    -- 9-bit adder for fractions
    ADDER_FRAC: genericAdder
        GENERIC MAP (n => 9)
        PORT MAP (
            i_Ai       => mantA_aligned,
            i_Bi       => mantB_aligned,
            i_CarryIn  => '0',
            o_Sum      => frac_sum(8 DOWNTO 0),
            o_CarryOut => frac_sum(9)
        );
    
    -- Fraction Result Register (10 bits)
    REG_FRAC_RESULT: genericRegister
        GENERIC MAP (n => 10)
        PORT MAP (
            i_clock    => i_clock,
            i_resetBar => resetBar,
            i_load     => addFractions,
            i_data     => frac_sum,
            o_q        => regFracResult
        );
    
    -- ========================================================================
    -- EXPONENT SELECTION: Choose larger exponent
    -- ========================================================================
    
    MUX_EXP_SELECT: genericMux2to1
        GENERIC MAP (n => 7)
        PORT MAP (
            i_A   => regExpA,
            i_B   => regExpB,
            i_Sel => selectExp,  -- 0 = ExpA, 1 = ExpB
            o_Out => exp_selected
        );
    
    -- Exponent Result Register
    REG_EXP_RESULT: genericRegister
        GENERIC MAP (n => 7)
        PORT MAP (
            i_clock    => i_clock,
            i_resetBar => resetBar,
            i_load     => selectExp,
            i_data     => exp_selected,
            o_q        => regExpResult
        );
    
    -- ========================================================================
    -- NORMALIZATION: If sum >= 2, shift right and increment exponent
    -- ========================================================================
    
    -- Check if normalization needed (bit 9 or bit 8 is set)
    needsNorm <= regFracResult(9) or regFracResult(8);
    
    -- Shift fraction right by 1 if overflow
    frac_normalized <= std_logic_vector(shift_right(unsigned(regFracResult), 1)) when normalize = '1'
                       else regFracResult;
    
    -- Increment exponent
    ADDER_EXP_INC: genericAdder
        GENERIC MAP (n => 7)
        PORT MAP (
            i_Ai       => regExpResult,
            i_Bi       => (0 => '1', others => '0'),
            i_CarryIn  => '0',
            o_Sum      => exp_incremented,
            o_CarryOut => exp_inc_carry
        );
    
    exp_normalized <= exp_incremented when normalize = '1' else regExpResult;
    
    -- ========================================================================
    -- FINAL OUTPUT
    -- ========================================================================
    
    -- For now, use Sign A (proper sign handling would require checking if same/different signs)
    regSignResult <= regSignA;
    
    SignOut      <= regSignResult;
    MantissaOut  <= frac_normalized(7 DOWNTO 0);  -- Remove implicit 1
    ExponentOut  <= exp_normalized;
    Overflow     <= exp_inc_carry;  -- Overflow if exponent increment carries out
    
END structural;